{"version":3,"sources":["scripts.js","FreshRejuvenations.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","FreshRejuvenations","this","windowScrollPosition","value","initStickyRequestConsultation","initRequestConsultationModalSlideout","initSlider","initParallaxSeparator","initImages","_this","$window","$","window","on","debounce","handlerWindowScroll","trigger","_this2","e","handlerClickRequestConsultationButton","Swiper","autoplay","pagination","Parallaxify","elements","backgroundYMin","backgroundYMax","registerUpdate","_this3","$images","each","index","imageGroup","$imageGroup","$imageTemplates","find","image","node","document","importNode","content","appendChild","remove","togglePageScroll","windowScroll","scrollTop","$requestConsultationButtonContainer","deviceStickyPoint","getDeviceStickyBreakpoint","css","getElementOffsetFromTopOfBrowser","removeAttr","preventDefault","displayRequestConsultationModal","_this4","$requestConsultationBackgrounOverlay","toggleClass","closeRequestConsultationModal","addClass","off","enabled","$element","offset","top","windowWidth","outerWidth","outerHeight","func","wait","immediate","timeout","context","args","arguments","later","apply","callNow","clearTimeout","setTimeout","ready","app","init"],"mappings":"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","file":"scripts.js","sourcesContent":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Class FreshRejuvenations\r\n */\n\nvar FreshRejuvenations = function () {\n  function FreshRejuvenations() {\n    _classCallCheck(this, FreshRejuvenations);\n\n    //Store the position of the window scroll when the request consultation button becomes sticky\n    this.windowScrollPosition = null;\n  }\n\n  /**\r\n   * Initialise the object\r\n   */\n\n\n  _createClass(FreshRejuvenations, [{\n    key: 'init',\n    value: function init() {\n      this.initStickyRequestConsultation();\n      this.initRequestConsultationModalSlideout();\n      this.initSlider();\n      this.initParallaxSeparator();\n      this.initImages();\n    }\n\n    /**\r\n     * Initialise the request consultation position so that when the window has scrolled down far enough,\r\n     * it becomes fixed so it will always be visible on the page\r\n     *\r\n     * @returns null\r\n     */\n\n  }, {\n    key: 'initStickyRequestConsultation',\n    value: function initStickyRequestConsultation() {\n      var _this = this;\n\n      var $window = $(window);\n      $window.on('scroll', this.debounce(function () {\n        _this.handlerWindowScroll();\n      }, 15));\n      $window.trigger('scroll');\n    }\n\n    /**\r\n     * Initialise the request consultation modal slideout\r\n     *\r\n     * @returns null\r\n     */\n\n  }, {\n    key: 'initRequestConsultationModalSlideout',\n    value: function initRequestConsultationModalSlideout() {\n      var _this2 = this;\n\n      $('.request-consultation-button').on('click', function (e) {\n        _this2.handlerClickRequestConsultationButton(e);\n      });\n    }\n\n    /**\r\n     * Initialise the hero image slider\r\n     */\n\n  }, {\n    key: 'initSlider',\n    value: function initSlider() {\n      new Swiper(\".swiper-container\", {\n        autoplay: 5000,\n        pagination: '.swiper-pagination'\n      });\n    }\n\n    /**\r\n     * Initialise the separators with a parralax background effet\r\n     */\n\n  }, {\n    key: 'initParallaxSeparator',\n    value: function initParallaxSeparator() {\n      new Parallaxify({\n        elements: \".our-work__section-divider\", // default\n        backgroundYMin: 100, // default\n        backgroundYMax: 0 // default\n      }).registerUpdate();\n    }\n\n    /**\r\n     * Loop through all images, taking them out of their <template> container, and putting them into the page DOM normally\r\n     *\r\n     * @returns null\r\n     */\n\n  }, {\n    key: 'initImages',\n    value: function initImages() {\n      var _this3 = this;\n\n      var $images = $(\".images\");\n\n      $images.each(function (index, imageGroup) {\n        var $imageGroup = $(imageGroup);\n        var $imageTemplates = $imageGroup.find(\"template\");\n        $.each($imageTemplates, function (i, image) {\n          var node = document.importNode(image.content, true);\n          imageGroup.appendChild(node);\n          image.remove();\n        });\n      });\n\n      $(document).on('lity:open', function () {\n        _this3.togglePageScroll(false);\n      });\n      $(document).on('lity:close', function () {\n        _this3.togglePageScroll(true);\n      });\n    }\n\n    /**\r\n     * Update the position of the request consultation button when the window scrolls past the breakpoint\r\n     *\r\n     * @returns null\r\n     */\n\n  }, {\n    key: 'handlerWindowScroll',\n    value: function handlerWindowScroll() {\n      var windowScroll = $(window).scrollTop();\n      var $requestConsultationButtonContainer = $(\".request-consultation-button-container\");\n      var deviceStickyPoint = this.getDeviceStickyBreakpoint();\n\n      //Once the Request Consultation button container is 200px from the top, set it to sticky\n      if ($requestConsultationButtonContainer.css('position') !== 'fixed' && this.getElementOffsetFromTopOfBrowser($requestConsultationButtonContainer) < deviceStickyPoint) {\n        $requestConsultationButtonContainer.css('position', 'fixed');\n        $requestConsultationButtonContainer.css('top', deviceStickyPoint + 'px');\n        this.windowScrollPosition = windowScroll; //Store the window scroll position when button becomes sticky\n      } else if (this.windowScrollPosition > windowScroll) {\n          //If the current window scroll is greater than the position at which the request consultation button became sticky, then it means it should no longer be\n          $requestConsultationButtonContainer.removeAttr('style');\n        }\n    }\n\n    /**\r\n     * Handle the even when the request consultation button is clicked\r\n     *\r\n     * @param {Event} e The click event\r\n     *\r\n     * @returns null\r\n     */\n\n  }, {\n    key: 'handlerClickRequestConsultationButton',\n    value: function handlerClickRequestConsultationButton(e) {\n      e.preventDefault();\n      this.displayRequestConsultationModal();\n    }\n\n    /**\r\n     * Display the request consultation modal\r\n     *\r\n     * This function will also attached the events that will fire to close the modal\r\n     *\r\n     * @returns null\r\n     */\n\n  }, {\n    key: 'displayRequestConsultationModal',\n    value: function displayRequestConsultationModal() {\n      var _this4 = this;\n\n      var $requestConsultationBackgrounOverlay = $(\".request-consultation_background-overlay\");\n      $requestConsultationBackgrounOverlay.toggleClass('off-canvas');\n\n      //Attach the click handlers\n      $requestConsultationBackgrounOverlay.on('click', function () {\n        _this4.closeRequestConsultationModal();\n      });\n      $('.request-consultation-modal__close-button').on('click', function () {\n        _this4.closeRequestConsultationModal();\n      });\n      this.togglePageScroll(false);\n    }\n\n    /**\r\n     * Close the request consultation modal\r\n     *\r\n     * This is done by adding the required class to the background overlay, triggering the CSS to hide both the overlay, and the modal iteself\r\n     *\r\n     * @return null\r\n     */\n\n  }, {\n    key: 'closeRequestConsultationModal',\n    value: function closeRequestConsultationModal() {\n      var $requestConsultationBackgrounOverlay = $(\".request-consultation_background-overlay\");\n      $requestConsultationBackgrounOverlay.addClass('off-canvas');\n\n      //Remove the click handlers\n      $requestConsultationBackgrounOverlay.off('click');\n      $('.request-consultation-modal__close-button').off('click');\n      this.togglePageScroll(true);\n    }\n\n    /**\r\n     * Enabled/disable page scrolling\r\n     *\r\n     * @param {boolean} enabled Flag indicating if scroll should be enabled or disabled\r\n     *\r\n     * @returns null\r\n     */\n\n  }, {\n    key: 'togglePageScroll',\n    value: function togglePageScroll(enabled) {\n      $(\"body\").toggleClass('noScroll', !enabled);\n    }\n\n    /**\r\n     * Get the px distance from the top of the element to the top edge of the browser window\r\n     *\r\n     * @param {jQuery} $element The element to get the offset for\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: 'getElementOffsetFromTopOfBrowser',\n    value: function getElementOffsetFromTopOfBrowser($element) {\n      return $element.offset().top - $(window).scrollTop();\n    }\n\n    /**\r\n     * Get the point at which the request consultation button should become sticky\r\n     *\r\n     * This is going to be different between small and large devices\r\n     */\n\n  }, {\n    key: 'getDeviceStickyBreakpoint',\n    value: function getDeviceStickyBreakpoint() {\n      var $window = $(window);\n      var windowWidth = $window.outerWidth();\n      var windowHeight = $window.outerHeight();\n\n      if (windowWidth > 1000) {\n        return 200;\n      } else if (windowWidth > 500) {\n        return 50;\n      }\n\n      return 10;\n    }\n\n    /**\r\n     * Returns a function, that, as long as it continues to be invoked, will not\r\n     * be triggered. The function will be called after it stops being called for\r\n     * N milliseconds. If `immediate` is passed, trigger the function on the\r\n     * leading edge, instead of the trailing.\r\n     *\r\n     * @param func\r\n     * @param wait\r\n     * @param immediate\r\n     *\r\n     * @returns {Function}\r\n     */\n\n  }, {\n    key: 'debounce',\n    value: function debounce(func, wait, immediate) {\n      var timeout;\n      return function () {\n        var context = this,\n            args = arguments;\n        var later = function later() {\n          timeout = null;\n          if (!immediate) func.apply(context, args);\n        };\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) func.apply(context, args);\n      };\n    }\n  }]);\n\n  return FreshRejuvenations;\n}();\n\n$(document).ready(function () {\n  var app = new FreshRejuvenations();\n  app.init();\n});","/**\r\n * Class FreshRejuvenations\r\n */\r\nclass FreshRejuvenations {\r\n\r\n  constructor() {\r\n    //Store the position of the window scroll when the request consultation button becomes sticky\r\n    this.windowScrollPosition = null;\r\n  }\r\n\r\n  /**\r\n   * Initialise the object\r\n   */\r\n  init() {\r\n    this.initStickyRequestConsultation();\r\n    this.initRequestConsultationModalSlideout();\r\n    this.initSlider();\r\n    this.initParallaxSeparator();\r\n    this.initImages();\r\n  }\r\n\r\n  /**\r\n   * Initialise the request consultation position so that when the window has scrolled down far enough,\r\n   * it becomes fixed so it will always be visible on the page\r\n   *\r\n   * @returns null\r\n   */\r\n  initStickyRequestConsultation() {\r\n    var $window = $(window);\r\n    $window.on('scroll', this.debounce(() => {this.handlerWindowScroll()}, 15));\r\n    $window.trigger('scroll');\r\n  }\r\n\r\n  /**\r\n   * Initialise the request consultation modal slideout\r\n   *\r\n   * @returns null\r\n   */\r\n  initRequestConsultationModalSlideout() {\r\n    $('.request-consultation-button').on('click', (e) => {this.handlerClickRequestConsultationButton(e)});\r\n  }\r\n\r\n  /**\r\n   * Initialise the hero image slider\r\n   */\r\n  initSlider() {\r\n    new Swiper(\".swiper-container\", {\r\n      autoplay: 5000,\r\n      pagination: '.swiper-pagination'\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Initialise the separators with a parralax background effet\r\n   */\r\n  initParallaxSeparator() {\r\n    new Parallaxify({\r\n      elements: \".our-work__section-divider\", // default\r\n      backgroundYMin: 100, // default\r\n      backgroundYMax: 0 // default\r\n    }).registerUpdate();\r\n  }\r\n\r\n  /**\r\n   * Loop through all images, taking them out of their <template> container, and putting them into the page DOM normally\r\n   *\r\n   * @returns null\r\n   */\r\n  initImages() {\r\n    var $images = $(\".images\");\r\n\r\n    $images.each((index, imageGroup) => {\r\n      const $imageGroup     = $(imageGroup);\r\n      const $imageTemplates = $imageGroup.find(\"template\");\r\n      $.each($imageTemplates, (i, image) => {\r\n        let node = document.importNode(image.content, true);\r\n        imageGroup.appendChild(node);\r\n        image.remove();\r\n      });\r\n    });\r\n\r\n    $(document).on('lity:open', () => {\r\n      this.togglePageScroll(false);\r\n    });\r\n    $(document).on('lity:close', () => {\r\n      this.togglePageScroll(true);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update the position of the request consultation button when the window scrolls past the breakpoint\r\n   *\r\n   * @returns null\r\n   */\r\n  handlerWindowScroll() {\r\n    const windowScroll = $(window).scrollTop();\r\n    const $requestConsultationButtonContainer = $(\".request-consultation-button-container\");\r\n    const deviceStickyPoint = this.getDeviceStickyBreakpoint();\r\n\r\n    //Once the Request Consultation button container is 200px from the top, set it to sticky\r\n    if ($requestConsultationButtonContainer.css('position') !== 'fixed' && this.getElementOffsetFromTopOfBrowser($requestConsultationButtonContainer) < deviceStickyPoint) {\r\n      $requestConsultationButtonContainer.css('position', 'fixed');\r\n      $requestConsultationButtonContainer.css('top', deviceStickyPoint+'px');\r\n      this.windowScrollPosition = windowScroll; //Store the window scroll position when button becomes sticky\r\n    } else if (this.windowScrollPosition > windowScroll) {\r\n      //If the current window scroll is greater than the position at which the request consultation button became sticky, then it means it should no longer be\r\n      $requestConsultationButtonContainer.removeAttr('style');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle the even when the request consultation button is clicked\r\n   *\r\n   * @param {Event} e The click event\r\n   *\r\n   * @returns null\r\n   */\r\n  handlerClickRequestConsultationButton(e) {\r\n    e.preventDefault();\r\n    this.displayRequestConsultationModal();\r\n  }\r\n\r\n  /**\r\n   * Display the request consultation modal\r\n   *\r\n   * This function will also attached the events that will fire to close the modal\r\n   *\r\n   * @returns null\r\n   */\r\n  displayRequestConsultationModal() {\r\n    let $requestConsultationBackgrounOverlay = $(\".request-consultation_background-overlay\");\r\n    $requestConsultationBackgrounOverlay.toggleClass('off-canvas');\r\n\r\n    //Attach the click handlers\r\n    $requestConsultationBackgrounOverlay.on('click', () => {this.closeRequestConsultationModal()});\r\n    $('.request-consultation-modal__close-button').on('click', () => {this.closeRequestConsultationModal()});\r\n    this.togglePageScroll(false);\r\n  }\r\n\r\n  /**\r\n   * Close the request consultation modal\r\n   *\r\n   * This is done by adding the required class to the background overlay, triggering the CSS to hide both the overlay, and the modal iteself\r\n   *\r\n   * @return null\r\n   */\r\n  closeRequestConsultationModal() {\r\n    let $requestConsultationBackgrounOverlay = $(\".request-consultation_background-overlay\");\r\n    $requestConsultationBackgrounOverlay.addClass('off-canvas');\r\n\r\n    //Remove the click handlers\r\n    $requestConsultationBackgrounOverlay.off('click');\r\n    $('.request-consultation-modal__close-button').off('click');\r\n    this.togglePageScroll(true);\r\n  }\r\n\r\n  /**\r\n   * Enabled/disable page scrolling\r\n   *\r\n   * @param {boolean} enabled Flag indicating if scroll should be enabled or disabled\r\n   *\r\n   * @returns null\r\n   */\r\n  togglePageScroll(enabled) {\r\n    $(\"body\").toggleClass('noScroll', !enabled);\r\n  }\r\n\r\n  /**\r\n   * Get the px distance from the top of the element to the top edge of the browser window\r\n   *\r\n   * @param {jQuery} $element The element to get the offset for\r\n   *\r\n   * @returns {number}\r\n   */\r\n  getElementOffsetFromTopOfBrowser($element) {\r\n    return $element.offset().top - $(window).scrollTop();\r\n  }\r\n\r\n  /**\r\n   * Get the point at which the request consultation button should become sticky\r\n   *\r\n   * This is going to be different between small and large devices\r\n   */\r\n  getDeviceStickyBreakpoint() {\r\n    const $window      = $(window);\r\n    const windowWidth  = $window.outerWidth();\r\n    const windowHeight = $window.outerHeight();\r\n\r\n    if (windowWidth > 1000) {\r\n      return 200;\r\n    } else if (windowWidth > 500) {\r\n      return 50;\r\n    }\r\n\r\n    return 10;\r\n  }\r\n\r\n  /**\r\n   * Returns a function, that, as long as it continues to be invoked, will not\r\n   * be triggered. The function will be called after it stops being called for\r\n   * N milliseconds. If `immediate` is passed, trigger the function on the\r\n   * leading edge, instead of the trailing.\r\n   *\r\n   * @param func\r\n   * @param wait\r\n   * @param immediate\r\n   *\r\n   * @returns {Function}\r\n   */\r\n  debounce(func, wait, immediate) {\r\n    var timeout;\r\n    return function() {\r\n      var context = this, args = arguments;\r\n      var later = function() {\r\n        timeout = null;\r\n        if (!immediate) func.apply(context, args);\r\n      };\r\n      var callNow = immediate && !timeout;\r\n      clearTimeout(timeout);\r\n      timeout = setTimeout(later, wait);\r\n      if (callNow) func.apply(context, args);\r\n    };\r\n  };\r\n}\r\n\r\n$(document).ready(() => {\r\n  const app = new FreshRejuvenations();\r\n  app.init();\r\n});\r\n"],"sourceRoot":"/source/"}